# 디버깅

## 1. 디버깅의 중요성과 디버깅 접근 전략
소프트웨어 개발에서 **디버깅**(debugging)은 필수적인 과정입니다. 버그를 방치하면 프로그램 오작동은 물론, 사용자 신뢰 저하와 시간/자원 손실로 이어질 수 있습니다. 따라서 버그를 발견하면 체계적으로 접근하여 원인을 찾고 수정해야 합니다.  

**● 재현 가능한 상황 만들기:** 우선 **버그를 확실히 재현할 수 있는 입력과 환경**을 준비해야 합니다. 가능한 한 **작고 반복 가능한 테스트 케이스**를 만들어 두면 좋습니다. 예를 들어 사용자 보고로 발견된 버그라면, 동일한 현상을 일으키는 최소한의 입력이나 시나리오를 찾습니다. 이렇게 하면 디버깅 과정에서 해당 케이스를 여러 번 실행해보며 안정적으로 문제를 추적할 수 있고, 수정 후에도 이 케이스로 재시험하여 버그가 재발하지 않는지 확인할 수 있습니다. 또한 GUI 프로그램이나 멀티스레드 환경처럼 타이밍에 민감한 버그라도, 최대한 동일한 순서와 조건으로 실행되도록 환경을 통제하면 문제를 잡는 데 큰 도움이 됩니다.  

**● 입력/출력 확인 및 가설 검증:** 버그 상황을 재현한 후에는 **프로그램의 실제 동작을 면밀히 관찰**해야 합니다. 잘못된 출력이나 에러 메시지 등 **겉으로 드러난 증상**을 먼저 수집합니다. 그런 다음 “어떤 부분에 문제가 있길래 이런 증상이 나타날까?” 추측해봅니다. 추측한 원인을 검증하기 위해 **중간 단계의 입력과 출력, 변수 값들을 확인**하는 것이 중요합니다. 예를 들어 함수의 반환값이 이상하다면, 함수에 들어가는 인자와 내부 계산 과정의 값들을 출력(logging)해서 정상 범위인지 확인합니다. 이런 식으로 데이터를 관찰하고, 관찰 결과에 기반해 가설을 세운 뒤, 다시 필요한 정보를 수집하는 **실험**을 반복합니다. 이렇게 하면 점차 문제가 없는 부분을 제외하면서 **의심 가는 영역을 좁혀나갈 수 있습니다**.  

**● 의심 영역 좁히기:** 프로그램을 모듈별 또는 단계별로 나누어 생각하면서, **문제가 없는 부분과 의심되는 부분을 구분**합니다. 예를 들어, 함수 A가 B를 호출하고 B가 C를 호출하는 흐름에서 증상이 C에서 나타난다면, 일단 A와 B보다는 **C 함수 내부**를 의심해야겠지요. 반대로 C의 결과가 이상하지만 C 자체에는 문제가 없다면, C에 건네는 **입력 값을 생성하는 상위 로직**에 문제가 있을 수 있습니다. 또 다른 기법으로 **이분법적인 좁혀가기**가 있습니다. 예를 들어 버그가 발생하는 입력 데이터가 매우 크다면, 그 절반만 넣어서도 버그가 생기는지 확인합니다. 만약 절반의 데이터로는 버그가 나타나지 않으면, 문제는 데이터 뒷부분에 있을 가능성이 높습니다. 반대로 절반으로 줄인 데이터에서도 여전히 문제가 발생한다면, 더 작은 절반으로 다시 시도합니다. 이런 식으로 입력 범위를 이분법으로 줄여가며 버그 발생 요인을 찾는 것은 효과적인 전략입니다. 이러한 과정은 마치 **디버깅 탐정**이 되어 단서를 수집하고 용의자를 제외해나가는 것과 같습니다. 최종적으로 남은 의심 부분이 바로 버그의 원인일 가능성이 높습니다.

## 2. VS Code에서 Python 디버거 사용법
현대적인 IDE인 **Visual Studio Code**(VS Code)는 강력한 Python 디버깅 도구를 제공합니다. **중단점**(breakpoint)을 걸고 한 줄씩 실행을 따라가며 변수 값을 실시간으로 확인할 수 있어, 논리 오류를 잡거나 프로그램 흐름을 이해하는 데 매우 유용합니다. 다음은 VS Code 디버거의 주요 기능과 활용법입니다.

- **중단점 설정:** 중단점은 특정 줄에서 프로그램 실행을 일시 정지시키는 표시입니다. VS Code 편집기 좌측 줄 번호 옆 여백을 클릭하면 빨간 점(●)이 나타나며 중단점이 설정됩니다 (또는 해당 줄에서 **F9** 키를 눌러도 됩니다). 중단점이 설정된 줄 이전까지 코드를 실행하고 그 지점에서 멈춤으로써, 그 순간의 변수 상태를 살펴볼 수 있습니다. 필요한 만큼 여러 군데 중단점을 걸어둘 수도 있으며, **좌측 디버그 패널**의 BREAKPOINTS 섹션에서 모든 중단점 리스트를 관리하거나 일괄 활성/비활성화할 수 있습니다.

- **디버그 모드 시작:** 중단점을 걸었다면, VS Code 좌측의 초록색 ▶️ **Run and Debug** 버튼이나 **F5** 키로 디버깅을 시작합니다. Python 파일을 처음 디버깅할 때는 어떤 환경으로 실행할지 **디버그 구성**(launch.json)을 선택하라는 창이 뜨는데, 일반적인 경우 “**Python File**”을 선택하면 현재 열린 파일을 디버깅합니다. 프로그램이 실행되다가 중단점에 도달하면 코드가 일시 정지되고, IDE 화면에 디버깅을 위한 여러 정보가 표시됩니다.

- **코드 한 줄씩 실행** (Step In/Over/Out): 디버깅 모드에서 특히 유용한 기능이 **코드 한 줄씩 실행**하는 기능입니다. **Step Over**(F10) 버튼을 누르면 현재 줄을 실행하고 다음 줄에서 멈춥니다. 함수 호출 라인에서 Step Over를 하면, 그 함수 내부를 한 줄씩 들여다보진 않고 호출 결과만 받아와 계속 진행합니다. 반면 **Step Into**(F11)를 사용하면 함수 호출 라인에서 그 함수 내부로 들어가 첫 줄부터 디버깅을 이어갈 수 있습니다. 만약 함수 내부로 들어갔다가 다시 밖으로 나오고 싶다면 **Step Out**(Shift+F11)을 사용하여 현재 함수의 나머지 부분은 한꺼번에 실행하고 복귀합니다. 이러한 단계 실행을 통해 코드 흐름을 세밀하게 추적하면, 어디서부터 예기치 않은 값이 생기는지 등을 쉽게 파악할 수 있습니다.  

- **변수 값 검사 및 Watch:** 디버깅 중에는 변수 창(Variables)에서 실시간으로 값이 변하는 걸 볼 수 있습니다. 컬렉션 자료형일 경우 펼쳐서 내부 요소까지 확인할 수도 있습니다. 또한 특정 변수나 표현식을 **Watch**에 등록해 두면, 해당 값이 실행 진행에 따라 어떻게 바뀌는지 한 눈에 추적할 수 있습니다. 예를 들어, 재귀 함수에서 재귀 깊이를 나타내는 변수가 있다면 `depth` 변수를 Watch에 추가하여 증가/감소를 모니터링할 수 있습니다. 또는 복잡한 수식 `n <= 1 or flag is True` 같은 논리 표현식을 Watch에 넣어두고, 반복문을 도는 동안 언제 참/거짓이 되는지 관찰할 수도 있습니다. 이러한 기능들은 일일이 `print`를 찍지 않고도 **프로그램의 상태를 투명하게 들여다볼 수 있게 해주므로**, 디버깅 생산성을 크게 높여줍니다.

- **콜 스택**(Call Stack) **확인**: 콜 스택 창은 현재까지 호출된 함수들의 **계층적 목록**을 보여줍니다. 이는 예외가 발생했을 때 **에러의 근원지를 추적**하거나, 재귀 호출이나 복잡한 함수 호출로 이루어진 코드의 실행 흐름을 이해하는 데 특히 중요합니다. 예를 들어 A 함수가 B를 호출하고, B가 C를 호출하다가 에러가 발생했다면, 콜 스택에는 순서대로 `C -> B -> A`가 나타나며, 개발자는 C에서 문제를 찾으면 되는 것이죠. 콜 스택의 각 레벨을 클릭하면 해당 함수의 일시정지 시점으로 전환되어 그 시점의 변수 상태 등을 확인할 수 있습니다.

- **예외**(Exception) **발생 시 멈춤**: VS Code 디버거는 코드에 중단점을 지정하지 않아도 **예외가 발생하는 순간 자동으로 멈추게** 할 수도 있습니다. 좌측 **BREAKPOINTS** 패널에서 `Raised Exceptions`나 `Uncaught Exceptions` 옵션을 체크하면, Python 코드에서 예외가 던져지는 시점에 실행을 중단합니다. 이 기능을 활성화하면 try/except로 잡히지 않은 에러는 물론, 잡힌 예외라도 발생 순간에 콜 스택을 확인할 수 있어 원인 파악에 도움이 됩니다.  

> **실습 Tip:** 간단한 코드로 디버거 연습해보기 – 예를 들어 아래와 같은 코드에서 중단점을 걸고, `Step Into/Over`를 해보세요.
> ```python
> def add(a, b):
>     return a + b
> 
> x = 5
> y = 3
> result = add(x, y)  # 이 줄에 중단점 설정
> print("Result:", result)  # 결과 출력
> ```
> 중단점에서 실행이 멈추면, `Step Into`를 눌러 `add` 함수 내부로 들어가보세요. 그런 다음 한 줄씩 실행하며 `a`, `b` 등의 값을 **변수 창**에서 확인해 보고, `Step Out`으로 함수 밖으로 다시 나오는 동작도 시도해보세요. 이렇게 간단한 사례로 디버거 조작에 익숙해지면, 이후에 복잡한 코드에서도 어려움 없이 활용할 수 있습니다.

## 3. `logging` 모듈을 이용한 디버깅 예시
때로는 디버거를 사용할 수 없는 상황이거나, 코드 흐름을 중단시키지 않고 **실행 로그를 남기며 문제를 추적**하고 싶을 때가 있습니다. 이럴 때는 파이썬 내장 **`logging` 모듈**을 활용한 디버깅이 유용합니다. 간단히 `print()`로 값을 출력하는 것도 방법이지만, `logging`은 그보다 훨씬 체계적이고 강력합니다.  

**● print 디버깅의 한계:** `print()` 함수는 쉽고 빠르게 값을 확인할 수 있어서 자주 쓰입니다. 하지만 규모가 있는 프로그램에서는 print로 찍어볼 수 있는 내용에 한계가 있습니다. 출력의 양을 동적으로 조절하기 어렵고, 모든 메시지가 한 통로로 뒤섞여 나와서 중요한 정보와 덜 중요한 정보가 구분되지 않습니다. 또한 배포 시에는 일일이 이 `print`들을 지우거나 주석 처리해야 할 수도 있고, 파일 등으로 로그를 저장하기도 번거롭습니다. 결국 **필요한 순간에만 필요한 수준의 정보**를 볼 수 있도록 관리가 어렵다는 점이 print 디버깅의 문제입니다. 실제 파이썬 가이드에서도 “커맨드라인 도움말 출력같이 정말 print가 더 적절한 경우를 제외하면, 거의 모든 상황에서 `logging`을 사용하는 편이 낫다”고 할 정도입니다.

**● logging 모듈의 장점:** `logging` 모듈을 사용하면 **로그 메시지에 등급(level)을 부여**하여 중요도에 따라 필터링하거나 다른 처리를 할 수 있습니다. 기본 로그 레벨은 DEBUG < INFO < WARNING < ERROR < CRITICAL 다섯 단계가 있으며, 로그를 출력할 때 각 메시지에 레벨을 지정합니다. 그리고 로거를 설정할 때 어느 레벨까지 출력할지 결정하면, 그보다 낮은 중요도의 메시지는 자동으로 무시됩니다. 예를 들어 디버깅 단계에서는 상세한 DEBUG 메시지까지 보다가, 운영 단계에서는 WARNING 이상만 출력하도록 조절할 수 있습니다. 또한 `logging`은 **시간, 파일 이름, 코드 위치 등 부가 정보**를 함께 기록할 수 있고, 원하는 포맷(format)으로 정렬하여 보여줄 수 있습니다. print로는 개발자가 일일이 꾸며줘야 할 정보들을 logging이 체계적으로 관리해주는 것이죠. 게다가 **파일 출력, 콘솔 출력, 이메일 전송 등 다양한 핸들러**를 통해 로그를 자유롭게 처리할 수 있고, 서드파티 서비스와 연동하여 모니터링하는 것도 용이합니다. 따라서 로그가 누적되면 추후에 **버그 재현이나 성능 분석 자료**로도 활용할 수 있어 일석이조입니다.

**● 기본 사용법:** Python 표준 모듈인 `logging`을 사용하려면 우선 `import logging` 한 후, **기본 설정**을 해야 합니다. `logging.basicConfig()` 함수를 통해 로그 레벨, 포맷, 출력 파일 등을 지정할 수 있습니다. 가장 간단히는 `logging.basicConfig(level=logging.DEBUG)`처럼 레벨만 지정하면, DEBUG 이상 모든 로그가 콘솔에 출력됩니다. 조금 더 활용하면 다음과 같이 포맷과 파일 출력까지 설정할 수 있습니다:

```python
import logging

logging.basicConfig(filename='debug.log', level=logging.DEBUG,
                    format='%(asctime)s [%(levelname)s] %(message)s')
```

위 설정을 하면 현재 디렉터리에 `debug.log` 파일이 만들어지고, DEBUG 등급 이상의 모든 로그가 **시간(asctime), 등급(levelname), 메시지** 형식으로 파일에 기록됩니다. 이제 로그를 남기고 싶은 곳에서 `logging.debug("디버깅용 상세 메시지")`처럼 호출하면 됩니다. `logging.info()`는 일반 정보, `logging.warning()`은 경고, `logging.error()`는 에러, `logging.critical()`은 심각한 치명적 오류를 나타냅니다.  

**● 예제: logging으로 디버깅하기** – 간단한 계산 함수에 logging을 적용해 보겠습니다. 아래 코드에서는 입력 값으로 나누기를 수행하면서, 단계마다 로그를 남깁니다:

```python
import logging

logging.basicConfig(level=logging.DEBUG,
                    format='%(levelname)s:%(message)s')

def divide(a, b):
    logging.debug(f"divide({a}, {b}) 함수 호출")      # debug: 상세 정보
    try:
        result = a / b
        logging.debug(f"연산 결과 = {result}")         # debug: 상세 정보
        return result
    except ZeroDivisionError:
        logging.error("0으로 나누는 에러 발생!")        # error: 에러 상황 기록
        return None

x, y = 6, 3
logging.info(f"{x}를 {y}로 나눕니다")                   # info: 일반 정보
print("결과:", divide(x, y))

x, y = 5, 0
logging.info(f"{x}를 {y}로 나눕니다")
print("결과:", divide(x, y))
```

위 코드 실행 시 콘솔에는 다음과 같은 로그가 출력됩니다 (DEBUG 레벨까지 출력하도록 했으므로 모든 메시지가 보입니다):

```
INFO:6를 3로 나눕니다
DEBUG:divide(6, 3) 함수 호출
DEBUG:연산 결과 = 2.0
결과: 2.0
INFO:5를 0로 나눕니다
DEBUG:divide(5, 0) 함수 호출
ERROR:0으로 나누는 에러 발생!
결과: None
```

첫 번째 계산에서는 정상적으로 2.0 결과가 나왔고, 두 번째 계산에서는 0으로 나눠 에러가 발생하여 `None`을 반환한 것을 볼 수 있습니다. **로그의 레벨별 태그와 메시지**를 통해 프로그램 흐름을 이해하기 쉽고, `print`로 출력한 **결과 값과도 깔끔하게 구분**되는 것을 확인할 수 있습니다. 이처럼 logging을 활용하면 코드를 수정하지 않고도 로그 레벨만 바꿔서 출력 양을 조절할 수 있고, 로그를 파일로 남겨 나중에 분석하는 것도 가능해집니다.  

> **실습 Tip:** 자신의 코드에 logging 적용해보기 – 간단한 반복이나 함수에서 `print`로 디버깅하던 부분을 `logging`으로 바꿔 보세요. 예를 들어 리스트 처리 함수라면 시작과 끝에 `logging.info("함수 시작")`, `logging.info("함수 끝")`을 넣고, 중간 중요한 분기마다 `logging.debug()`로 변수 값을 기록해보는 식입니다. 그런 다음 레벨을 INFO로 설정하면 상세 디버그는 감추고 정보만 보이게 할 수 있습니다. 이렇게 하면 나중에 코드를 지우지 않아도 되고, 필요할 때만 상세 내용을 볼 수 있어 편리합니다.

## 4. 디버깅 실습: 버그가 포함된 코드 수정하기
이제 실제로 **버그가 있는 코드**를 살펴보고 디버깅을 통해 수정해보겠습니다. 여기 두 가지 파이썬 코드 예제가 있습니다. 각 코드에는 고의로 버그를 심어두었으니, 앞서 배운 디버깅 기법을 활용하여 문제를 찾아 수정해보세요.

### 🔍 예제 1: 재귀 함수의 버그 찾기
아래 코드는 팩토리얼(Factorial)을 계산하는 재귀 함수입니다. 의도한 기능은 `factorial(5)` 등 양의 정수 `n`을 넣으면 `n!`을 계산해서 반환하는 것입니다. 코드를 실행하면 어떤 일이 벌어지는지 확인하고, 버그를 수정해보세요.

```python
def factorial(n):
    if n == 1:  # 버그가 있다! (힌트: 0!도 1이어야 합니다)
        return 1
    else:
        return n * factorial(n - 1)

print("5! =", factorial(5))
print("0! =", factorial(0))
```

**실행 결과 확인:** 위 코드를 그대로 실행하면 `5! = 120`까지는 정상적으로 보이지만, 곧 에러가 발생합니다. `factorial(0)` 호출에서 문제가 생긴 것 같네요. 출력된 **에러 메시지(Traceback)**를 보면 마지막 줄에 `RecursionError: maximum recursion depth exceeded` 라고 나올 것입니다. 이 뜻은 **재귀 호출이 끝나지 않고 계속되어 최대 깊이를 초과했다**는 것으로, `factorial(0)` 호출이 무한 재귀에 빠졌음을 의미합니다.

**문제 원인 추적:** 왜 `factorial(0)`에서 재귀가 끝나지 않을까요? 코드를 보면 재귀를 멈추는 탈출 조건(base case)이 `if n == 1`로 되어 있습니다. 수학적으로 0! = 1 이지만, 현재 함수는 0 입력에 대한 처리가 없어서 `factorial(0)` → `0 * factorial(-1)` → `-1 * factorial(-2)` … 이런 식으로 끝없이 재귀를 호출하게 됩니다. 즉, **팩토리얼의 탈출 조건이 잘못 설정**된 버그입니다. 이 버그를 확인하는 과정에서 디버거를 활용할 수도 있습니다. `factorial(0)` 호출 전에 중단점을 걸고 실행한 뒤, **콜 스택**을 보면 `factorial` 함수가 계속해서 자신을 호출하는 스택이 쌓이는 걸 관찰할 수 있습니다. 또는 함수 내에 `logging.debug(f"n={n}")`을 넣어봐도 n 값이 0, -1, -2… 끝없이 내려감을 알 수 있죠.

**버그 수정:** 해결책은 간단합니다 – **탈출 조건을 `n == 0`으로 변경**하거나, 0과 1 두 가지를 모두 커버하도록 조건을 작성하면 됩니다. 여기서는 0일 때도 1을 반환하도록 고쳐보겠습니다.

```python
def factorial(n):
    if n == 0 or n == 1:  # 0 또는 1인 경우 1을 반환 (수정 완료)
        return 1
    else:
        return n * factorial(n - 1)

print("5! =", factorial(5))
print("0! =", factorial(0))
```

이제 다시 실행하면 `5! = 120` 그리고 `0! = 1`이 출력되고 에러는 발생하지 않습니다. 재귀함수가 정확히 종료되면서 원하는 결과를 얻었습니다. 이 예제를 통해, **함수의 종료 조건이 중요함**을 알 수 있습니다. 디버깅할 때는 이렇게 함수의 입력과 출력이 각각 어떻게 되는지 추적하여 논리에 빠진 부분은 없는지 살펴보면 좋습니다.

### 🔍 예제 2: 루프 논리 버그 찾기
다음 코드는 동일하게 팩토리얼을 계산하지만, 이번에는 **반복문**으로 구현했습니다. 의도는 `number` 값에 대해 팩토리얼 결과를 계산하여 출력하는 것입니다. 코드를 실행하고 결과가 맞는지 확인해보세요.

```python
factorial = 1
number = 6
for i in range(1, number + 1):
    factorial *= factorial * i  # 버그가 있다!
print(f"{number}! =", factorial)
```

**출력 확인:** 위 코드를 실행하면 `6! = 16511297126400` 같은 어마어마한 숫자가 나올 것입니다. 하지만 우리가 기대한 6!의 값은 720이죠. 오류는 있어도 프로그램이 비정상 종료되지는 않았지만, **출력된 결과가 명백히 잘못되었음**을 알 수 있습니다. 이런 유형을 **논리 버그**라고 합니다 (에러는 안 나지만 로직이 틀려 결과가 잘못 나옴).

**문제 원인 추적:** 어디가 잘못됐을까요? 코드를 천천히 살펴봅시다. `for i in range(1, number + 1):` 루프를 도는데, `factorial *= factorial * i` 이 한 줄에 버그가 숨어 있습니다. 일반적으로 팩토리얼 계산이라면 `factorial = factorial * i` 또는 축약해서 `factorial *= i` 여야 할 텐데, 여기서는 `factorial`을 한 번 더 곱하고 있습니다. 즉, **자기 자신을 중복으로 곱하는 오류**입니다. 루프를 추적해보면: 처음에 factorial=1, i=1일 때 `1 *= 1 * 1`로 1 유지. i=2일 때 `factorial = 1 * 1 * 2 = 2`. i=3일 때 `factorial = 2 * 2 * 3 = 12`. i=4일 때 `12 * 12 * 4 = 576`. 이렇게 제대로 계산해야 할 값(24, 120, 720)을 훌쩍 뛰어넘어 버리는 걸 알 수 있습니다. 이 과정은 **디버거**로 직접 확인할 수도 있습니다. VS Code 디버거로 위 코드에 중단점을 걸고 실행한 후, `factorial *= factorial * i` 라인에서 **Step Over**로 한 줄씩 진행하면서 **변수 factorial의 값이 어떻게 변하는지** 지켜보세요. 또는 Watch에 `factorial`을 추가해두면 루프 돌 때마다 값이 변하는 걸 실시간으로 볼 수 있습니다. 이런 방법으로도 `factorial` 값이 의도치 않게 커진다는 것을 쉽게 파악할 수 있습니다.

**버그 수정:** 해결책은 `factorial`을 한 번만 곱하도록 수정하는 것입니다. 즉, 잘못된 줄을 `factorial *= i`로 고치면 됩니다. 

```python
factorial = 1
number = 6
for i in range(1, number + 1):
    factorial *= i   # 수정: 자기 자신을 한 번만 곱하도록
print(f"{number}! =", factorial)
```

이제 실행하면 `6! = 720`으로 정상 출력됩니다. 이 예제에서는 **곱셈 로직의 사소한 실수**로 인해 결과가 완전히 달라졌습니다. 루프 내 계산이 복잡할 경우, 이렇게 **변수의 변화를 추적하거나 출력**해서 중간값을 확인해보는 것이 유용합니다. 또한 코드 리뷰나 Copilot 같은 도구를 통해 이런 실수를 자동으로 잡아낼 수 있는지도 생각해보면 좋습니다.

## 5. GitHub Copilot의 디버깅 활용
방금 실습한 버그들을 **GitHub Copilot**을 사용해서 찾아보면 어떨까요? Copilot은 AI 코드 도우미로 잘 알려져 있는데, 코드를 자동 완성해줄 뿐만 아니라 간단한 디버깅 조언도 얻을 수 있습니다. 여기서는 Copilot을 통해 버그의 원인을 설명받거나 수정 제안을 얻는 방법을 알아보겠습니다.

**● 코드 오류 설명 요청하기:** Copilot을 사용하면 에러 메시지나 문제 상황에 대해 질문을 던지고 답변을 얻을 수 있습니다. 특히 **Copilot Chat** 기능을 활용하면 대화형으로 디버깅 도움을 받을 수 있습니다. 예를 들어, 앞의 예제1에서 발생한 `RecursionError`를 Copilot에게 물어본다고 가정해봅시다. VS Code에서 Copilot Chat 창을 열고 (기본 단축키는 <kbd>Ctrl+Shift+I</kbd>), 다음과 같은 프롬프트를 입력합니다:

```
RecursionError가 발생하는 원인과 고치는 방법을 설명해줘.
```

Copilot은 이 질문을 읽고 해당 에러의 원인을 분석해 답변을 줄 것입니다. 예상 답변은 이런 식입니다: "이 코드는 `factorial` 함수의 재귀 종료 조건이 잘못되어 발생한 문제입니다. `n == 1`로만 설정되어 있어 `factorial(0)` 호출 시 무한 재귀에 빠집니다. 정solution로는 종료 조건을 `n == 0` 또는 `n <= 1`로 수정해야 합니다." Copilot은 이어서 수정된 코드 예시도 제시해줄 것입니다. 실제 GitHub 공식 문서에서도 Copilot이 이러한 **에러 원인 분석과 코드 수정**을 제안해주는 예시를 확인할 수 있습니다. Copilot이 알려준 대로 코드를 고쳐서 문제를 해결할 수 있겠지요.

또 다른 예로, **자료형 오류**를 Copilot에게 물어볼 수도 있습니다. 어떤 코드에서 `"TypeError: can only concatenate str (not \"int\") to str"` 같은 오류가 발생했다고 합시다. Copilot에게 *"왜 이 오류가 발생했나요? 어떻게 고치죠?"*라고 물으면, **문자열과 정수를 더하려 해서 생긴 오류이며 정수를 `str()`로 변환하면 해결된다는 설명**과 함께 수정 코드까지 제시해줍니다. 이처럼 Copilot은 흔히 보는 파이썬 예외들에 대해 어느 정도 이유와 대응법을 알고 있어서, 설명을 구하면 비교적 정확한 답을 들을 수 있습니다.

**● 논리 버그 수정 제안 받기:** Copilot은 명시적인 오류 메시지가 없는 **논리 버그**도 도와줄 수 있습니다. 예제2의 잘못된 팩토리얼 코드처럼 **출력만 틀리고 에러는 없는 경우**, Copilot에게는 상황을 좀 더 상세히 설명해주는 것이 좋습니다. Copilot Chat에 해당 코드를 첨부하고, *"이 코드는 6!를 계산하려는데 결과가 예상보다 훨씬 크게 나옵니다. 원인을 분석하고 고쳐주세요."* 라고 요청해본다고 가정해봅시다. Copilot은 코드를 검토한 뒤 답을 줄 것입니다. 공식 문서의 유사한 사례를 보면 Copilot은 이렇게 설명합니다: "**루프에서 `*=` 연산자를 사용하고 있어 `factorial` 변수가 자기 자신까지 곱해지고 있다**. 그 결과 매 반복마다 `factorial`이 한 번 더 곱해지므로 값이 폭증하는 것이라고 지적합니다. 그리고 해결책으로 `factorial` 곱셈에서 자기 자신을 빼거나 (`factorial = factorial * i`로 수정) 연산을 변경할 것을 제안합니다." 실제로 Copilot이 수정 코드를 제시한다면 아마 다음과 같을 것입니다:

```python
for i in range(1, number + 1):
    factorial *= i  # Copilot 제안 수정: 자기 자신을 곱하지 않도록 변경
```

Copilot의 분석과 수정 제안을 통해 우리는 버그를 좀 더 빨리 이해하고 고칠 수 있습니다. 특히 **수식이 복잡하거나 알고리즘적 실수**의 경우 Copilot에게 물어보면, 문제 부분을 콕 집어주므로 유용합니다.

**● Copilot 사용 방법 요령:** Copilot에게 디버깅 도움을 받을 때는 **질문을 구체적으로** 하는 것이 좋습니다. 단순히 “이 코드 고쳐줘”보다는, “어떤 입력에서 어떤 결과가 나와야 하는데 실제로는 뭐가 나온다”거나 “어떤 에러가 발생한다”는 식으로 맥락을 충분히 주는 것입니다. Copilot은 주어진 프롬프트에 따라 답을 생성하므로, 우리가 겪는 문제를 명확히 설명할수록 정확한 도움을 받을 확률이 높아집니다. 또한 Copilot이 제안한 해결책이 이해되지 않는다면, **추가로 설명을 요구**할 수도 있습니다. 예를 들어 “왜 이렇게 해야 하나요?”라고 물으면 Copilot이 한층 자세히 논리를 풀어서 설명해줍니다. 이런 대화형 활용을 통해 Copilot을 마치 rubber duck(고무 오리)처럼 사용하면 디버깅에 큰 도움이 될 수 있습니다.

> **실습 Tip:** Copilot과 디버깅 대화 나눠보기 – VS Code의 Copilot Chat 확장(또는 Copilot Labs)이 설치되어 있다면, 직접 위 버그 코드를 입력하고 Copilot과 Q&A를 진행해보세요. 예제2의 코드에 대해 *"출력이 잘못 나온 이유가 뭐야?"*라고 물어보고 Copilot의 답을 확인해보세요. 그리고 *"그럼 코드를 어떻게 고칠까?"*라고 계속 질문을 던져 보세요. Copilot이 제안한 수정 코드를 에디터에 적용하고, 정말로 문제가 해결되는지 실행으로 검증해보세요. Copilot의 설명을 들으며 디버깅하는 연습은, 마치 동료 개발자와 페어 프로그래밍을 하는 듯한 효과를 주어 사고력을 향상시키는 데 도움이 됩니다.

## 6. 실습 요약 및 Copilot이 제안하는 코드의 한계와 검토 방법
이번 실습을 통해 **디버깅의 기본 전략**(문제 재현, 로그/중단점 활용, 범위 좁히기)과 **VS Code 디버거 사용법**, 그리고 **logging을 활용한 디버깅 기법**을 연습했습니다. 또한 **GitHub Copilot을 디버깅 도우미로 활용**하는 방법도 알아보았습니다. 정리하자면 다음과 같습니다:

- 버그를 다룰 때는 우선 재현 가능한 최소 상황을 만들고, 증상을 면밀히 관찰하면서 가설을 세우고 검증하여 원인을 좁혀나갑니다.  
- VS Code 디버거를 쓰면 코드의 실행을 중단점에서 멈추고 내부 상태를 보며 한 줄씩 따라갈 수 있으므로, 복잡한 버그를 잡는 데 매우 효과적입니다.  
- `logging` 모듈은 print보다 체계적인 디버깅을 가능하게 하며, 특히 실서비스 코드에 디버깅 정보를 남길 때 유용합니다 (로그 레벨 관리, 파일 저장 등).  
- GitHub Copilot은 코드 자동완성뿐만 아니라, 버그 원인 설명이나 수정 제안을 통해 디버깅 시간을 단축시킬 수 있습니다. Copilot에게 문제를 질의하면 에러의 원인을 분석해주거나, 잘못된 코드를 바로잡아주는 예시를 제공하기도 합니다.

마지막으로, **Copilot의 한계와 올바른 활용법**에 대해 언급하고 마치겠습니다. Copilot은 뛰어난 도구이지만 아직 사람만큼 완벽하지는 않습니다. 때로는 질문을 제대로 이해하지 못해 엉뚱한 답을 내놓기도 하고, 개발자의 의도와 다르게 동문서답하거나 관련없는 코드를 제시하는 경우도 있습니다. Copilot이 제안한 코드가 항상 최적이거나 오류가 없는 것도 아닙니다 – 보안에 취약한 코드를 알려주거나 프로젝트 문맥에 맞지 않는 코드를 넣어줄 수도 있다는 지적이 있습니다. 실제로 Copilot이 논리 버그를 완벽하게 잡아주는 것도 아니며, 가끔은 존재하지 않는 문제를 지적하는 **환각(hallucination)** 현상도 보고되고 있습니다.

그러므로 Copilot의 도움을 받더라도 **최종 책임은 개발자에게 있음**을 명심해야 합니다. Copilot이 제안한 수정사항은 항상 본인이 직접 이해하고 검증해야 합니다. 가능하면 **유닛 테스트**를 통해 Copilot 코드가 제대로 동작하는지 확인하고, 코드 리뷰를 거쳐 품질을 담보하는 것이 좋습니다. Copilot은 어디까지나 **생산성을 높여주는 보조 도구**일 뿐이며, 핵심적인 디버깅 사고 과정 (문제 분석, 논리적 추론)은 개발자 본인이 주도해야 합니다.  

결론적으로, 전통적인 디버깅 기법과 최신 AI 도구를 적절히 병행하면 개발 효율을 크게 높일 수 있습니다. VS Code의 강력한 디버거와 logging으로 **코드를 투명하게 들여다보는 능력**을 갖추고, Copilot의 도움으로 **빠른 문제 파악과 수정 아이디어**를 얻되, 최종 검증은 스스로 하는 습관을 들이세요. 이러한 균형 잡힌 접근이 **뛰어난 디버거**로 성장하는 지름길입니다. 🎯
